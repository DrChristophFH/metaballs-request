<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Metaball Dots from Image</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Prevent image dragging ghost */
        * {
            -webkit-user-drag: none;
        }

        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>

<body class="min-h-screen bg-slate-900 text-slate-100">
    <header class="w-full border-b border-slate-800 bg-slate-900/80 backdrop-blur sticky top-0 z-10">
        <div class="mx-auto max-w-6xl px-4 py-3 flex items-center justify-between">
            <h1 class="font-semibold tracking-tight text-lg">
                Metaball Dots Visualizer
            </h1>
            <div class="flex items-center gap-2 text-xs text-slate-400">
                <span class="hidden md:inline">Drag an image or click to upload · <a
                        href="https://github.com/DrChristophFH/metaballs-request"
                        class="text-indigo-400 underline decoration-dotted">GitHub</a></span>
                <button id="reuploadBtn" class="hidden rounded-lg border border-slate-700 px-3 py-1 hover:bg-slate-800">
                    Upload another
                </button>
            </div>
        </div>
    </header>

    <main class="mx-auto max-w-6xl px-4 py-10">
        <!-- Drop Zone -->
        <section id="dropzone" class="relative mx-auto max-w-3xl">
            <label for="fileInput"
                class="group block rounded-2xl border-2 border-dashed border-slate-700 p-10 text-center cursor-pointer hover:border-slate-600 transition-colors">
                <div
                    class="mx-auto w-20 h-20 rounded-full bg-slate-800/60 grid place-items-center mb-6 group-hover:bg-slate-800">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-10 h-10" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M12 16a1 1 0 0 0 1-1V9.41l1.3 1.3a1 1 0 1 0 1.4-1.42l-3-3a1 1 0 0 0-1.4 0l-3 3A1 1 0 1 0 9.7 10.7L11 9.4V15a1 1 0 0 0 1 1z" />
                        <path
                            d="M20 13a1 1 0 0 0-1 1 5 5 0 0 1-5 5H8a6 6 0 1 1 1.09-11.9 1 1 0 1 0 .36-1.96A8 8 0 1 0 8 21h6a7 7 0 0 0 7-7 1 1 0 0 0-1-1z" />
                    </svg>
                </div>
                <p class="text-lg font-medium">Drag & drop an image here</p>
                <p class="text-slate-400 mt-1">or <span class="text-indigo-400 underline decoration-dotted">click to
                        choose a file</span></p>
                <p class="text-xs text-slate-500 mt-4">PNG · JPG · JPEG · GIF (first frame)</p>
            </label>
            <input id="fileInput" type="file" accept="image/*" class="sr-only" />
        </section>

        <!-- Controls -->
        <section id="controls" class="hidden mt-6">
            <div class="rounded-2xl border border-slate-800 bg-slate-900/60 backdrop-blur p-5">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-sm font-semibold text-slate-200">Controls</h2>
                    <p class="text-xs text-slate-400">Changes apply instantly. Use mouse wheel over canvas to adjust
                        grid
                        density.</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Padding -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Padding</span><span id="ctl-padding-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-padding" type="range" min="0" max="80" step="1" class="w-full accent-indigo-500">
                    </label>
                    <!-- Base Cols -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Base Cols</span><span id="ctl-baseCols-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-baseCols" type="range" min="4" max="128" step="1"
                            class="w-full accent-indigo-500">
                    </label>
                    <!-- Max Cols -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Max Cols</span><span id="ctl-maxCols-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-maxCols" type="range" min="4" max="128" step="1"
                            class="w-full accent-indigo-500">
                    </label>
                    <!-- Gamma -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Gamma</span><span id="ctl-gamma-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-gamma" type="range" min="0.1" max="3" step="0.05"
                            class="w-full accent-indigo-500">
                    </label>
                    <!-- v (bulge) -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Bulge (v)</span><span id="ctl-v-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-v" type="range" min="0" max="1" step="0.01" class="w-full accent-indigo-500">
                    </label>
                    <!-- Handle Len Rate -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Handle Len Rate</span><span
                                id="ctl-handleLenRate-val" class="text-slate-400"></span></div>
                        <input id="ctl-handleLenRate" type="range" min="0" max="5" step="0.1"
                            class="w-full accent-indigo-500">
                    </label>
                    <!-- Influence Scale -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Influence Scale</span><span
                                id="ctl-influenceScale-val" class="text-slate-400"></span></div>
                        <input id="ctl-influenceScale" type="range" min="0" max="6" step="0.1"
                            class="w-full accent-indigo-500">
                    </label>
                    <!-- Cutoff -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Cutoff</span><span id="ctl-cutoff-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-cutoff" type="range" min="0.05" max="3" step="0.01" class="w-full accent-indigo-500">
                    </label>
                    <!-- Field Strength -->
                    <label class="block text-xs">
                        <div class="flex justify-between mb-1"><span>Field Strength</span><span id="ctl-strength-val"
                                class="text-slate-400"></span></div>
                        <input id="ctl-strength" type="range" min="0.1" max="5" step="0.01" class="w-full accent-indigo-500">
                    </label>
                    <!-- Colors -->
                    <div class="grid grid-cols-2 gap-4">
                        <label class="block text-xs">
                            <div class="mb-1">Dot Color</div>
                            <input id="ctl-dotFill" type="color" class="w-full h-8 rounded cursor-pointer"
                                title="Dot Fill">
                        </label>
                        <label class="block text-xs">
                            <div class="mb-1">Blob Color</div>
                            <input id="ctl-blobFill" type="color" class="w-full h-8 rounded cursor-pointer"
                                title="Blob Fill">
                        </label>
                    </div>
                </div>
            </div>
        </section>

        <!-- Canvas Stage -->
        <section id="stage" class="hidden relative mt-6 rounded-2xl overflow-hidden border border-slate-800">
            <div
                class="absolute left-4 top-4 z-10 rounded-xl bg-slate-900/70 backdrop-blur px-3 py-2 text-xs text-slate-300 border border-slate-700">
                Resize window to fit · Scroll to zoom grid
            </div>
            <canvas id="canvas" class="w-full h-[70vh] block bg-white"></canvas>
        </section>

        <!-- Tiny footer note -->
        <p id="hint" class="mt-8 text-center text-xs text-slate-500">
            Tip: darker areas create bigger dots; neighboring dots blend via a metaball connection.
        </p>
    </main>

    <script>
        // ====== UI elements ======
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const stage = document.getElementById('stage');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const reuploadBtn = document.getElementById('reuploadBtn');
        const controlsSection = document.getElementById('controls');

        // ====== Config (tweakable) ======
        const CONFIG = {
            padding: 24,           // padding around the grid inside canvas (CSS pixels)
            baseCols: 12,         // default grid columns for sampling (auto-scales)
            maxCols: 40,          // safety limit
            gamma: 1.0,            // >1 makes small dots smaller, <1 makes them larger
            v: 0.5,                // metaball "bulge" factor [0..1]
            handleLenRate: 2.4,    // bezier handle scale
            maxDistFactor: 1.1,   // max connection distance in multiples of cell size
            influenceScale: 2.0,   // how far a circle's field reaches, as a multiple of its radius
            fieldCutoff: 0.6,      // threshold for field -> colored pixel
            fieldStrength: 1.0,    // scales contribution of each circle to the field
            dotFill: '#000000',    // slate-900-ish fill for dots (will look near-black)
            blobFill: '#000000'    // same color for connections
        };

        // ====== App state ======
        const state = {
            img: null,
            cols: 0,
            rows: 0,
            gray: null,   // Float32Array of darkness [0..1], index = y*cols + x
            cellSize: 0,
            offsetX: 0,
            offsetY: 0,
            maxRadius: 0,
            scale: 1,
        };

        // ====== Helpers: vectors ======
        const V = (x = 0, y = 0) => ({ x, y });
        const add = (a, b) => V(a.x + b.x, a.y + b.y);
        const sub = (a, b) => V(a.x - b.x, a.y - b.y);
        const mul = (a, s) => V(a.x * s, a.y * s);
        const len = (a) => Math.hypot(a.x, a.y);
        const ang = (a) => Math.atan2(a.y, a.x);
        const fromAngleLen = (radians, length) => V(Math.cos(radians) * length, Math.sin(radians) * length);
        const dist = (a, ra, b, rb) => Math.hypot(a.x - b.x, a.y - b.y) - (ra + rb);

        // ====== Metaball bridge between two circles (translated from Paper.js logic) ======
        function metaballBridge(ball1, ball2, v, handle_len_rate, maxDistance) {
            // ball: {position: {x,y}, radius: r}
            const center1 = ball1.position;
            const center2 = ball2.position;
            let r1 = ball1.radius;
            let r2 = ball2.radius;

            if (r1 <= 0 || r2 <= 0) return null;

            const d = dist(center1, r1, center2, r2);
            if (d > maxDistance || d <= Math.abs(r1 - r2) || d === 0) return null;

            let u1, u2;
            if (d < r1 + r2) {
                u1 = Math.acos((r1 * r1 + d * d - r2 * r2) / (2 * r1 * d));
                u2 = Math.acos((r2 * r2 + d * d - r1 * r1) / (2 * r2 * d));
            } else {
                u1 = 0;
                u2 = 0;
            }

            const angle1 = ang(sub(center2, center1));         // angle C1->C2
            const angle2 = Math.acos((r1 - r2) / d);
            const angle1a = angle1 + u1 + (angle2 - u1) * v;
            const angle1b = angle1 - u1 - (angle2 - u1) * v;
            const angle2a = angle1 + Math.PI - u2 - (Math.PI - u2 - angle2) * v;
            const angle2b = angle1 - Math.PI + u2 + (Math.PI - u2 - angle2) * v;

            const p1a = add(center1, fromAngleLen(angle1a, r1));
            const p1b = add(center1, fromAngleLen(angle1b, r1));
            const p2a = add(center2, fromAngleLen(angle2a, r2));
            const p2b = add(center2, fromAngleLen(angle2b, r2));

            const totalRadius = r1 + r2;
            let d2 = Math.min(v * handle_len_rate, len(sub(p1a, p2a)) / totalRadius);
            d2 *= Math.min(1, (d * 2) / (r1 + r2));

            const r1h = r1 * d2;
            const r2h = r2 * d2;

            const pi2 = Math.PI / 2;
            const Ao = fromAngleLen(angle1a - pi2, r1h);
            const Bi = fromAngleLen(angle2a + pi2, r2h);
            const Co = fromAngleLen(angle2b - pi2, r2h);
            const Di = fromAngleLen(angle1b + pi2, r1h);

            return { A: p1a, B: p2a, C: p2b, D: p1b, Ao, Bi, Co, Di };
        }

        // ====== Sampling image to grayscale darkness ======
        function sampleImageToGray(img, targetCols) {
            const off = document.createElement('canvas');
            const ratio = img.height / img.width;
            const cols = Math.max(4, Math.min(CONFIG.maxCols, Math.floor(targetCols)));
            const rows = Math.max(4, Math.round(cols * ratio));
            const oddRowCompensation = Math.floor(rows / 2);
            off.width = cols;
            off.height = rows;
            const octx = off.getContext('2d', { willReadFrequently: true });

            // Draw first frame if animated (GIF); browser does this by default
            octx.drawImage(img, 0, 0, cols, rows);
            const { data } = octx.getImageData(0, 0, cols, rows);

            const gray = new Float32Array(cols * rows);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const cellIndex = y * cols + x;
                    const pixelIndex = (cellIndex * 4); // pixel index in data

                    if (y % 2 === 1) {
                        if (x + 1 == cols) continue; // skip last pixel in odd rows to avoid out-of-bounds

                        const r1 = data[pixelIndex], g1 = data[pixelIndex + 1], b1 = data[pixelIndex + 2];
                        const r2 = data[pixelIndex + 4], g2 = data[pixelIndex + 5], b2 = data[pixelIndex + 6];
                        const lum1 = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1;
                        const lum2 = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2;
                        const avgLum = (lum1 + lum2) / 2;
                        const darkness = 1 - (avgLum / 255);
                        gray[cellIndex] = Math.max(0, Math.min(1, darkness));
                    } else {
                        const r = data[pixelIndex], g = data[pixelIndex + 1], b = data[pixelIndex + 2];
                        const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;     // linear-ish luminance
                        const darkness = 1 - (lum / 255);
                        gray[cellIndex] = Math.max(0, Math.min(1, darkness));
                    }
                }
            }

            return { cols, rows, gray };
        }

        function isOddRow(index, cols) {
            // Odd rows are those where the index is odd when divided by cols
            return Math.floor(index / cols) % 2 === 1;
        }

        // ====== Canvas sizing (HiDPI aware) ======
        function resizeCanvasToDisplaySize() {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            const needResize = canvas.width !== Math.floor(displayWidth * dpr) ||
                canvas.height !== Math.floor(displayHeight * dpr);
            if (needResize) {
                canvas.width = Math.floor(displayWidth * dpr);
                canvas.height = Math.floor(displayHeight * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing ops to CSS pixels
            }
        }

        // ====== Compute grid geometry from current canvas & sample ======
        function computeGrid() {
            const W = canvas.clientWidth;
            const H = canvas.clientHeight;
            const pad = CONFIG.padding;

            // Fit grid into padded area while preserving sample aspect
            const cellSizeX = (W - 2 * pad) / state.cols;
            const cellSizeY = (H - 2 * pad) / state.rows;
            state.cellSize = Math.max(1, Math.min(cellSizeX, cellSizeY));
            const gridW = state.cellSize * state.cols;
            const gridH = state.cellSize * state.rows;
            state.offsetX = Math.floor((W - gridW) / 2);
            state.offsetY = Math.floor((H - gridH) / 2);

            state.maxRadius = state.cellSize * 0.49; // keep inside cell
        }

        // ====== Metaball scalar field (finite-support kernel) ======
        function hexToRgb(hex) {
            let h = hex.startsWith('#') ? hex.slice(1) : hex;
            if (h.length === 3) h = h.split('').map(c => c + c).join('');
            const n = parseInt(h, 16);
            return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
        }

        // Accumulate field by rasterizing only inside each circle's influence radius.
        // Field contribution per circle: w * (1 - d^2/R^2)^3 for d < R, else 0 (compact support, smooth).
        function renderMetaballField(circles) {
            const dpr = window.devicePixelRatio || 1;
            const W = canvas.width;   // device pixels
            const H = canvas.height;  // device pixels
            if (W === 0 || H === 0) return;

            const field = new Float32Array(W * H);
            const strength = CONFIG.fieldStrength;
            const inflScale = Math.max(0, CONFIG.influenceScale);

            // Rasterize each circle's influence region
            for (let i = 0; i < circles.length; i++) {
                const c = circles[i];
                const rCss = c.radius;
                if (rCss <= 0) continue;
                const Rcss = rCss * inflScale;
                if (Rcss <= 0.001) continue;

                // Convert to device px
                const R = Rcss * dpr;
                const R2 = R * R;
                const cx = c.position.x * dpr;
                const cy = c.position.y * dpr;

                let x0 = Math.max(0, Math.floor(cx - R));
                let y0 = Math.max(0, Math.floor(cy - R));
                let x1 = Math.min(W - 1, Math.ceil(cx + R));
                let y1 = Math.min(H - 1, Math.ceil(cy + R));

                // Weight larger dots slightly higher (normalized by maxRadius)
                const weight = (rCss > 0 && state.maxRadius > 0) ? (rCss / state.maxRadius) : 1;
                const scale = strength * weight;
                if (scale <= 0) continue;

                for (let y = y0; y <= y1; y++) {
                    const dy = (y + 0.5) - cy;
                    const dy2 = dy * dy;
                    let idx = y * W + x0;
                    for (let x = x0; x <= x1; x++, idx++) {
                        const dx = (x + 0.5) - cx;
                        const d2 = dx * dx + dy2;
                        if (d2 >= R2) continue;
                        const t = 1 - (d2 / R2);           // [0..1)
                        const contrib = scale * (t * t * t); // (1 - s)^3
                        field[idx] += contrib;
                    }
                }
            }

            // Threshold -> RGBA overlay
            const cutoff = CONFIG.fieldCutoff;
            if (!(cutoff > 0)) return;

            const color = hexToRgb(CONFIG.blobFill || '#000000');
            const off = document.createElement('canvas');
            off.width = W; off.height = H;
            const octx = off.getContext('2d');
            const img = octx.createImageData(W, H);
            const data = img.data;

            for (let i = 0, p = 0; i < field.length; i++, p += 4) {
                if (field[i] >= cutoff) {
                    data[p] = color.r;
                    data[p + 1] = color.g;
                    data[p + 2] = color.b;
                    data[p + 3] = 255;
                } else {
                    // transparent
                    data[p + 3] = 0;
                }
            }

            octx.putImageData(img, 0, 0);

            // Draw to main canvas at device resolution (putImageData ignores transforms)
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(off, 0, 0);
            ctx.restore();
        }

        // ====== Render ======
        function draw() {
            if (!state.gray) return;
            resizeCanvasToDisplaySize();
            computeGrid();

            // Clear
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
            ctx.fillStyle = CONFIG.dotFill;

            const cols = state.cols, rows = state.rows;
            const cs = state.cellSize;
            const offX = state.offsetX;
            const offY = state.offsetY;

            // Precompute circle positions and radii for this draw
            const circles = new Array(cols * rows);
            const gamma = CONFIG.gamma;

            for (let y = 0; y < rows; y++) {
                const additionalOffset = y % 2 === 1 ? cs / 2 : 0; // offset odd rows

                for (let x = 0; x < cols; x++) {
                    const i = y * cols + x;
                    const darkness = Math.pow(state.gray[i], gamma); // map via gamma
                    const r = darkness * state.maxRadius;
                    const cx = Math.floor(offX + x * cs + cs / 2 + additionalOffset);
                    const cy = Math.floor(offY + y * cs + cs / 2);
                    circles[i] = { position: V(cx, cy), radius: r };
                }
            }

            // Draw dots
            for (let i = 0; i < circles.length; i++) {
                ctx.beginPath();
                const { position: p, radius: r } = circles[i];
                if (r <= 0.25) continue;
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Render metaball field overlay instead of bezier bridges
            renderMetaballField(circles);
        }

        // ====== Load image from File ======
        async function handleFiles(files) {
            if (!files || !files.length) return;
            const file = files[0];

            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file.');
                return;
            }

            // Create image
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                URL.revokeObjectURL(url);

                // Decide sampling density based on canvas width (if available) or viewport
                const containerWidth = (canvas.parentElement?.clientWidth || window.innerWidth);
                const targetCols = Math.min(
                    CONFIG.maxCols,
                    Math.max(CONFIG.baseCols, Math.floor(containerWidth / 8)) // ~8px per cell as a start
                );

                const samp = sampleImageToGray(img, targetCols);
                state.img = img;
                state.cols = samp.cols;
                state.rows = samp.rows;
                state.gray = samp.gray;

                // Flip UI
                dropzone.classList.add('hidden');
                stage.classList.remove('hidden');
                reuploadBtn.classList.remove('hidden');
                controlsSection.classList.remove('hidden');

                // Initial draw
                draw();
            };
            img.onerror = () => {
                URL.revokeObjectURL(url);
                alert('Could not load this image.');
            };
            img.src = url;
        }

        // ====== Events: drag & drop + file input ======
        ; (() => {
            const dz = dropzone;

            function setHover(on) {
                dz.firstElementChild.classList.toggle('border-indigo-500', on);
                dz.firstElementChild.classList.toggle('bg-slate-900/40', on);
            }

            dz.addEventListener('dragover', (e) => { e.preventDefault(); setHover(true); });
            dz.addEventListener('dragleave', () => setHover(false));
            dz.addEventListener('drop', (e) => {
                e.preventDefault();
                setHover(false);
                const files = e.dataTransfer.files;
                handleFiles(files);
            });

            fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

            reuploadBtn.addEventListener('click', () => {
                // Reset UI to choose another file
                stage.classList.add('hidden');
                reuploadBtn.classList.add('hidden');
                dropzone.classList.remove('hidden');
                controlsSection.classList.add('hidden');
                fileInput.value = '';
                state.img = null;
                state.gray = null;
                ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
            });

            // Zoom grid density with wheel (Ctrl/Cmd for precision)
            stage.addEventListener('wheel', (e) => {
                if (!state.gray) return;
                const delta = Math.sign(e.deltaY);
                const current = state.cols;
                const next = Math.max(5, Math.min(CONFIG.maxCols, current + delta));
                if (next !== current && state.img) {
                    const samp = sampleImageToGray(state.img, next);
                    state.cols = samp.cols;
                    state.rows = samp.rows;
                    state.gray = samp.gray;
                    draw();
                }
                e.preventDefault();
            }, { passive: false });

            // Handle resize
            window.addEventListener('resize', () => draw());
            // Ensure canvas has a reasonable initial height in case CSS changes
            new ResizeObserver(() => draw()).observe(canvas);

            // Bind control panel
            function bindControls() {
                const $ = (id) => document.getElementById(id);
                const setVal = (id, val) => { const s = $(id + '-val'); if (s) s.textContent = String(val); };
                const bindRange = (id, key, parser = parseFloat) => {
                    const el = $(id);
                    if (!el) return;
                    el.value = CONFIG[key];
                    setVal(id, CONFIG[key]);
                    el.addEventListener('input', () => {
                        CONFIG[key] = parser(el.value);
                        setVal(id, CONFIG[key]);
                        if (key === 'maxCols' && state.img && state.cols > CONFIG.maxCols) {
                            const samp = sampleImageToGray(state.img, Math.min(state.cols, CONFIG.maxCols));
                            state.cols = samp.cols; state.rows = samp.rows; state.gray = samp.gray;
                        }
                        draw();
                    });
                };
                bindRange('ctl-padding', 'padding', parseInt);
                bindRange('ctl-baseCols', 'baseCols', parseInt);
                bindRange('ctl-maxCols', 'maxCols', parseInt);
                bindRange('ctl-gamma', 'gamma', parseFloat);
                bindRange('ctl-v', 'v', parseFloat);
                bindRange('ctl-handleLenRate', 'handleLenRate', parseFloat);
                bindRange('ctl-maxDistFactor', 'maxDistFactor', parseFloat);
                bindRange('ctl-influenceScale', 'influenceScale', parseFloat);
                bindRange('ctl-cutoff', 'fieldCutoff', parseFloat);
                bindRange('ctl-strength', 'fieldStrength', parseFloat);

                const bindColor = (id, key) => {
                    const el = $(id);
                    if (!el) return;
                    el.value = CONFIG[key];
                    el.addEventListener('input', () => { CONFIG[key] = el.value; draw(); });
                };
                bindColor('ctl-dotFill', 'dotFill');
                bindColor('ctl-blobFill', 'blobFill');
            }
            bindControls();

            // For testing purposes, load a sample image
            if (location.search.includes('sample')) {
                const sampleImg = 'https://cdn.pixabay.com/photo/2021/06/04/10/28/portrait-6309448_1280.jpg';
                // fetch file and convert to Blob
                fetch(sampleImg)
                    .then(response => response.blob())
                    .then(blob => {
                        const file = new File([blob], 'sample.jpg', { type: 'image/jpeg' });
                        console.log('Loaded sample image:', file);
                        handleFiles([file]);
                    })
                    .catch(err => console.error('Failed to load sample image:', err));
            }
        })();

        // ====== Testing Stuff ======
        function circlesAs2D(circles) {
            const rows = state.rows;
            const cols = state.cols;
            const arr = new Array(rows);
            for (let y = 0; y < rows; y++) {
                arr[y] = new Array(cols);
                for (let x = 0; x < cols; x++) {
                    const i = y * cols + x;
                    arr[y][x] = circles[i];
                }
            }
            return arr;
        }
    </script>
</body>

</html>